table(top$Plant_Species)
unique(top$combo[order(top$avg)])
top2$combo_fact <- factor(top2$combo, levels=unique(top$combo[order(top$avg)]), ordered=TRUE)
#pdf(file="test.pdf", height=4, width=12)
ggplot(data=top2, aes(x=combo_fact, y=scaled_avg, fill=model))+geom_col(position="dodge", stat="identity")
spear.matrix_full <- cor(composite[,4:10], method="spearman")
knitr::opts_chunk$set(echo = TRUE)
composite <- Traits %>% select(., -real) %>% left_join(Phy, ., by = c("Frugivore_Species", "Plant_Species"))
composite
View(pred)
?pivot_wider()
pred %>% pivot_wider(., names_from="model")
pred %>% pivot_wider(., names_from="model", values_from=scaled_avg)
x <-pred %>% pivot_wider(., names_from="model", values_from=scaled_avg)
View(x)
x <-pred %>% dplyr::select(., model, combo, real, scaled_avg)%>% pivot_wider(., names_from="model", values_from=scaled_avg)
composite <-pred %>% dplyr::select(., model, combo, real, scaled_avg)%>% pivot_wider(., names_from="model", values_from=scaled_avg)
View(composite)
spear.matrix_full <- cor(composite[,3:9], method="spearman")
corrplot::corrplot(spear.matrix_full, type = "lower", diag=T, order = "AOE", main="Spearman: all")
spear.matrix_full
?cor()
spear.matrix_full <- cor(composite[,3:9], method="spearman", use="complete.obs")
corrplot::corrplot(spear.matrix_full, type = "lower", diag=T, order = "AOE", main="Spearman: all")
spear.matrix_full <- cor(composite[,3:9], method="spearman",)
corrplot::corrplot(spear.matrix_full, type = "lower", diag=T, order = "AOE", main="Spearman: all")
spear.matrix_full <- cor(composite[,3:9], method="spearman", use="complete.obs")
corrplot::corrplot(spear.matrix_full, type = "lower", diag=T, order = "AOE", main="Spearman: all")
corr.matrix_full <- cor(composite[,4:10], method="pearson", use="complete.obs")
corr.matrix_full <- cor(composite[,3:9], method="pearson", use="complete.obs")
corrplot::corrplot(corr.matrix_full, type = "lower", diag=T, order = "AOE", main="Pearson: all")
spear.matrix_unreal <- cor(composite_unreal[,3:9], method="spearman", use="complete.obs")
composite %>% dplyr::filter(., real==1)
composite
composite %>% dplyr::filter(., real==1)
composite %>% dplyr::filter(., real==1) %>% dplyr::select(., -1, -2)
composite %>% dplyr::filter(., real==1) %>% dplyr::select(., -1, -2)
spear.matrix_unreal <- composite %>% dplyr::filter(., real==1) %>% dplyr::select(., -1, -2) %>% cor(., method="spearman", use="complete.obs")
corrplot::corrplot(spear.matrix_unreal, type = "lower", diag=T, order = "AOE", main="Spearman: unobserved")
spear.matrix_unreal <- composite %>% dplyr::filter(., real==1) %>% dplyr::select(., -1, -2) %>% cor(., method="spearman", use="complete.obs")
corrplot::corrplot(spear.matrix_unreal, type = "lower", diag=T, order = "AOE", main="Spearman: unobserved")
corr.matrix_unreal <- composite %>% dplyr::filter(., real==1) %>% dplyr::select(., -1, -2) %>% cor(., method="pearson", use="complete.obs")
corrplot::corrplot(corr.matrix_unreal, type = "lower", diag=T, order = "AOE", main="Pearson: unobserved")
par(mfrow = c(2, 2), oma=c(0,0,2,0))
corrplot::corrplot.mixed(spear.matrix_full, lower="number", upper="ellipse", diag=T, main="Spearman: All Links", mar=c(0,0,2,0))
par(mfrow = c(2, 2), oma=c(0,0,2,0))
corrplot::corrplot(spear.matrix_full, type = "lower", diag=T, main="Spearman: All Links", mar=c(0,0,2,0), method="ellipse")
corrplot::corrplot(corr.matrix_full, type = "lower", diag=T, main="Pearson: All Links", mar=c(0,0,2,0), method="ellipse")
corrplot::corrplot(spear.matrix_unreal, type = "lower", diag=T, main="Spearman: Unobserved Links", mar=c(0,0,2,0), method="ellipse")
corrplot::corrplot(corr.matrix_unreal, type = "lower", diag=T, main="Pearson: Unobserved Links", mar=c(0,0,2,0), method="ellipse")
par(mfrow = c(2, 2), oma=c(0,0,2,0))
corrplot::corrplot.mixed(spear.matrix_full, lower="number", upper="ellipse", diag=T, main="Spearman: All Links", mar=c(0,0,2,0))
par(mfrow = c(2, 2), oma=c(0,0,2,0))
corrplot::corrplot(spear.matrix_full, type = "lower", diag=T, main="Spearman: All Links", mar=c(0,0,2,0), method="ellipse")
corrplot::corrplot(corr.matrix_full, type = "lower", diag=T, main="Pearson: All Links", mar=c(0,0,2,0), method="ellipse")
corrplot::corrplot(spear.matrix_unreal, type = "lower", diag=T, main="Spearman: Unobserved Links", mar=c(0,0,2,0), method="ellipse")
corrplot::corrplot(corr.matrix_unreal, type = "lower", diag=T, main="Pearson: Unobserved Links", mar=c(0,0,2,0), method="ellipse")
par(mfrow = c(1, 2), oma=c(0,0,2,0))
corrplot::corrplot(spear.matrix_full, type = "lower", diag=T, main="Spearman: All Links", mar=c(0,0,2,0), method="ellipse")
corrplot::corrplot(spear.matrix_unreal, type = "lower", diag=T, main="Spearman: Unobserved Links", mar=c(0,0,2,0), method="ellipse")
corrplot::corrplot(spear.matrix_full, type = "lower", diag=T, main="All Potential Links", mar=c(0,0,2,0), method="ellipse")
corrplot::corrplot(spear.matrix_unreal, type = "lower", diag=T, main="Unobserved Links", mar=c(0,0,2,0), method="ellipse")
par(mfrow = c(1, 2), oma=c(0,0,2,0))
corrplot::corrplot(spear.matrix_full, type = "lower", diag=T, main="All Potential Links", mar=c(0,0,2,0), method="ellipse")
corrplot::corrplot(spear.matrix_unreal, type = "lower", diag=T, main="Unobserved Links", mar=c(0,0,2,0), method="ellipse")
pdf(file="ESA_Figs/SpearmanCorplot.pdf", width=8.5, height=9.2)
par(mfrow = c(1, 2), oma=c(0,0,2,0))
corrplot::corrplot(spear.matrix_full, type = "lower", diag=T, main="All Potential Links", mar=c(0,0,2,0), method="ellipse")
corrplot::corrplot(spear.matrix_unreal, type = "lower", diag=T, main="Unobserved Links", mar=c(0,0,2,0), method="ellipse")
dev.off()
pdf(file="ESA_Figs/SpearmanCorplot.pdf", width=8.5, height=6)
par(mfrow = c(1, 2), oma=c(0,0,2,0))
corrplot::corrplot(spear.matrix_full, type = "lower", diag=T, main="All Potential Links", mar=c(0,0,2,0), method="ellipse")
corrplot::corrplot(spear.matrix_unreal, type = "lower", diag=T, main="Unobserved Links", mar=c(0,0,2,0), method="ellipse")
dev.off()
knitr::opts_chunk$set(echo = TRUE)
plant_litter <- PVR::PVRdecomp(phy=BIEN_subtree, type="newick", scale=TRUE)
sum((round((plant_litter@Eigen$values)/sum((plant_litter@Eigen$values)),3)*100)[1:4])
plant_PhyEig <-data.frame(BIEN_subtree$tip.label, plant_litter@Eigen$vectors[,1:5])
colnames(plant_PhyEig) <- c("Plant_Species", paste(colnames(plant_PhyEig)[2:ncol(plant_PhyEig)], "PlDecomp", sep=""))
plant_PhyEig$Plant_Species <- gsub(pattern="_", replace=" ", x=plant_PhyEig$Plant_Species)
dat <- left_join(dat, plant_PhyEig, by="Plant_Species")
sum((round((plant_litter@Eigen$values)/sum((plant_litter@Eigen$values)),3)*100)[1:4])
frug_tree <- ape::compute.brlen(frug_tree, 1) #set branch lengths to 1
frug_litter <- PVR::PVRdecomp(phy=Bird_trees[[round(1)]], type="newick", scale=TRUE)
frug_litter
Bird_trees
Bird_trees[[round(1)]]
frug_litter <- PVR::PVRdecomp(phy=Bird_trees[[round(1)]], type="newick", scale=TRUE)
Bird_trees[[5]]
1:3
sum((round((plant_litter@Eigen$values)/sum((plant_litter@Eigen$values)),3)*100)[1:5]) #first three vectors contain about 42.6% of variation :(
sum((round((plant_litter@Eigen$values)/sum((plant_litter@Eigen$values)),3)*100)[1:5]) #first three vectors contain about 42.6% of variation :(
sum((round((plant_litter@Eigen$values)/sum((plant_litter@Eigen$values)),3)*100)[1:4]) #first three vectors contain about 42.6% of variation :(
bird_litter <- VR::PVRdecomp(phy=Bird_trees[[round(1)]], type="newick", scale=TRUE)
bird_litter <- PVR::PVRdecomp(phy=Bird_trees[[round(1)]], type="newick", scale=TRUE)
sum((round((bird_litter@Eigen$values)/sum((bird_litter@Eigen$values)),3)*100)[1:3]) #first three vectors contain about 42.6% of variation :(
temp <- NULL
for(i in 1:500){
bird_litter <- PVR::PVRdecomp(phy=Bird_trees[[round(1)]], type="newick", scale=TRUE)
rbind(sum((round((bird_litter@Eigen$values)/sum((bird_litter@Eigen$values)),3)*100)[1:3]), temp) #first three vectors contain about 42.6% of variation :(
}
temp
temp <- NULL
for(i in 1:500){
bird_litter <- PVR::PVRdecomp(phy=Bird_trees[[round(i)]], type="newick", scale=TRUE)
rbind(sum((round((bird_litter@Eigen$values)/sum((bird_litter@Eigen$values)),5)*100)[1:3]), temp) #first three vectors contain about 42.6% of variation :(
}
i <- 1
bird_litter <- PVR::PVRdecomp(phy=Bird_trees[[round(i)]], type="newick", scale=TRUE)
rbind(sum((round((bird_litter@Eigen$values)/sum((bird_litter@Eigen$values)),5)*100)[1:3]), temp)
rbind(sum((round((bird_litter@Eigen$values)/sum((bird_litter@Eigen$values)),5)*100)[1:3]), temp)
temp <- NULL
for(i in 1:500){
bird_litter <- PVR::PVRdecomp(phy=Bird_trees[[round(i)]], type="newick", scale=TRUE)
temp <- rbind(sum((round((bird_litter@Eigen$values)/sum((bird_litter@Eigen$values)),5)*100)[1:3]), temp) #first three vectors contain about 42.6% of variation :(
}
View(temp)
mean(temp)
sd(temp)
mean(temp)
sd(temp)
View(trio)
split_output
knitr::opts_chunk$set(echo = TRUE)
dat <- read.csv("Data.nosync/ATLANTIC_frugivory.csv")
dat %<>% dplyr::filter(., Frugivore_Species != "Carollia castanea") #This bat has an incorrect gape size, so it's filtered out
library(tidyverse)
library(magrittr)
library(igraph)
library(pROC)
library(BIEN)
library(np)
library(PVR)
library(ape)
library("phytools")
library(tictoc)
library(corrplot)
dat <- read.csv("Data.nosync/ATLANTIC_frugivory.csv")
dat %<>% dplyr::filter(., Frugivore_Species != "Carollia castanea") #This bat has an incorrect gape size, so it's filtered out
dat <- dplyr::select(dat, -ID, -Latitude, -Longitude, -Study_Location, -Precision, -Study_Method, -Study.reference, -Doi.Link, -Frug_Population_Trend, -Frug_Migration_status)
dat %<>% unique(.)
load("BIEN_subtree.Rda")
Mammal_trees <- ape::read.nexus(file="Data.nosync/VertLife_FrugMam/output.nex")
Bird_trees <- ape::read.nexus(file="Data.nosync/VertLife_FrugBird/output.nex")
#dat <- dplyr::filter_at(dat, vars(Plant_Form, Frugivory_score, Lipid_Score, Fruit_color, Plant_origin), all_vars(!is.na(.))) #make sure we have scores for all our binary variables
dat %<>%
filter(
across(
.cols = c(Plant_Form, Frugivory_score, Lipid_Score, Fruit_color, Plant_origin),
.fns = ~ !is.na(.x)
)
) #Make sure we have scores for all our binary variables
dat %<>% dplyr::filter(., Fruit_color !="") #This Remove blank fruit color entries
dat$Plant_origin[dat$Plant_origin !="native"] <- "nonnative" #condense all nonnative plants into one (can revisit later)
#dat$real <- 1 # note that these are real interactions; important when we expand later
dat_old <- dat
#dat$Frugivory_score <- paste("FrugScore", dat$Frugivory_score, sep="") #Make value names unambiguous as column names
#dat$Lipid_Score <- paste("LipScore", dat$Lipid_Score, sep="")
categories <- list(Forms=unique(dat$Plant_Form), #take the unique entries of our categorical data and save them in a list; (less typing to assign column names based on them below)
#Frugivory_score=unique(dat$Frugivory_score),
#Lipid_Score=unique(dat$Lipid_Score),
Fruit_color=unique(dat$Fruit_color),
Plant_origin=unique(dat$Plant_origin)
)
dat_old <- dat
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Plant_Form, values_from = bin)
#dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Frugivory_score, values_from = bin)
#dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Lipid_Score, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Fruit_color, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Plant_origin, values_from = bin)
dat[, which(colnames(dat)=="liana"):ncol(dat)][is.na(dat[,which(colnames(dat)=="liana"):ncol(dat)])==TRUE] <- 0 #Replae all NA's in our newly created columns with 0
dat <- left_join(dat, dat_old) #add back in our factor columns just in case we want them later
colnames(dat)
table(dat$white)
table(dat$wred)
table(dat$red)
table(dat$black)
View(dat)
knitr::opts_chunk$set(echo = TRUE)
colnames(dat)
dat_counts <- dplyr::select(dat, Plant_Species, tree, scrub, palm, herb, epiphyte, Hemiparasita, parasitic, yellow, black, red, brown, green, white, orange, multicolor, blue, pink)
colnames(dat)
table(dat$Plant_Form)
table(dat$Fruit_color)
table(dat$Plant_Form)
table(dat$Fruit_color)
range(dat$Frug_Body_Mass)
range(dat$Frug_Body_Mass, na.rm=T)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(magrittr)
library(igraph)
library(pROC)
library(BIEN)
library(np)
library(PVR)
library(ape)
library("phytools")
library(tictoc)
library(corrplot)
dat <- read.csv("Data.nosync/ATLANTIC_frugivory.csv")
dat %<>% dplyr::filter(., Frugivore_Species != "Carollia castanea") #This bat has an incorrect gape size, so it's filtered out
dat <- dplyr::select(dat, -ID, -Latitude, -Longitude, -Study_Location, -Precision, -Study_Method, -Study.reference, -Doi.Link, -Frug_Population_Trend, -Frug_Migration_status)
dat %<>% unique(.)
load("BIEN_subtree.Rda")
Mammal_trees <- ape::read.nexus(file="Data.nosync/VertLife_FrugMam/output.nex")
Bird_trees <- ape::read.nexus(file="Data.nosync/VertLife_FrugBird/output.nex")
#dat <- dplyr::filter_at(dat, vars(Plant_Form, Frugivory_score, Lipid_Score, Fruit_color, Plant_origin), all_vars(!is.na(.))) #make sure we have scores for all our binary variables
dat %<>%
filter(
across(
.cols = c(Plant_Form, Frugivory_score, Lipid_Score, Fruit_color, Plant_origin),
.fns = ~ !is.na(.x)
)
) #Make sure we have scores for all our binary variables
dat %<>% dplyr::filter(., Fruit_color !="") #This Remove blank fruit color entries
dat$Plant_origin[dat$Plant_origin !="native"] <- "nonnative" #condense all nonnative plants into one (can revisit later)
#dat$real <- 1 # note that these are real interactions; important when we expand later
dat_old <- dat
#dat$Frugivory_score <- paste("FrugScore", dat$Frugivory_score, sep="") #Make value names unambiguous as column names
#dat$Lipid_Score <- paste("LipScore", dat$Lipid_Score, sep="")
categories <- list(Forms=unique(dat$Plant_Form), #take the unique entries of our categorical data and save them in a list; (less typing to assign column names based on them below)
#Frugivory_score=unique(dat$Frugivory_score),
#Lipid_Score=unique(dat$Lipid_Score),
Fruit_color=unique(dat$Fruit_color),
Plant_origin=unique(dat$Plant_origin)
)
dat_old <- dat
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Plant_Form, values_from = bin)
#dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Frugivory_score, values_from = bin)
#dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Lipid_Score, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Fruit_color, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Plant_origin, values_from = bin)
dat[, which(colnames(dat)=="liana"):ncol(dat)][is.na(dat[,which(colnames(dat)=="liana"):ncol(dat)])==TRUE] <- 0 #Replae all NA's in our newly created columns with 0
dat <- left_join(dat, dat_old) #add back in our factor columns just in case we want them later
plant_litter <- PVR::PVRdecomp(phy=BIEN_subtree, type="newick", scale=TRUE)
sum((round((plant_litter@Eigen$values)/sum((plant_litter@Eigen$values)),3)*100)[1:4]) #first three vectors contain about 42.6% of variation :(
plant_PhyEig <-data.frame(BIEN_subtree$tip.label, plant_litter@Eigen$vectors[,1:5])
colnames(plant_PhyEig) <- c("Plant_Species", paste(colnames(plant_PhyEig)[2:ncol(plant_PhyEig)], "PlDecomp", sep=""))
plant_PhyEig$Plant_Species <- gsub(pattern="_", replace=" ", x=plant_PhyEig$Plant_Species)
dat <- left_join(dat, plant_PhyEig, by="Plant_Species")
birds <- dplyr::filter(dat, Frug_Class=="Aves")
table(birds$Plant_Form)
table(birds$Fruit_color)
range(birds$Frug_Body_Mass)
range(birds$Frug_Body_Mass, na.rm=TRUE)
View(birds)
range(birds$Frug_Mean_Gape_Size, na.rm=TRUE)
range(birds$fruit_diameter, na.rm=TRUE)
range(birds$fruit_length, na.rm=TRUE)
Bird_trees$tree_2110
Bird_trees$tree_2110$edge.length
Bird_trees$tree_2110$edge.length
Bird_trees$tree_2110$edge
load("~/Documents/Fruglink/fullReplicateRF_rfobs_23.Rda")
rf_output
rf_output[[1]]
rf_output[[1]]$Phy
load("~/Documents/Fruglink/fullReplicateRF.Rda")
n_animals <- 10
a_traitV <- runif(n_animals, 0.05, .25)
a_traitV
a_traitV/.25
a_traitV/.05
a_traitV/.25
a_traitV <- c(a_traitV, 0.05, 0.25)
a_traitV
a_traitV/0.25
traitV-max(traitV)
a_traitV-max(a_traitV)
a_traitV-min(a_traitV)
a_traitV-min(a_traitV)/0.2
(a_traitV-min(a_traitV))/0.2
a_traitV*-(0.25)
(a_traitV-min(a_traitV))/0.2
a_traitV-min(a_traitV)/0.25
a_traitV-0.25
(a_traitV-0.05)
(a_traitV-0.05)/0.2
plot(x=(a_traitV-0.05)/0.2, y=a_traitV)
knitr::opts_chunk$set(echo = TRUE)
scale2 <- function(x, input){
val <- (1-x)*((input-0.05)/0.2))+x
scale2 <- function(x, input){
val <- (1-x)*((input-0.05)/0.2)+x
}
scale2 <- function(x, input){
val <- (1-x)*((input-0.05)/0.2)+x
return(val)
}
scale2(x=0, input=a_traitV)
plot(x=a_traitV, y=scale2(x=0, input=a_traitV))
plot(x=a_traitV, y=scale2(x=0, input=a_traitV))
lines(x=a_traitV, y=scale2(x=0.4, input=a_traitV))
lines(x=a_traitV, y=scale2(x=0.1, input=a_traitV))
plot(x=a_traitV, y=scale2(x=0, input=a_traitV))
lines(x=a_traitV, y=scale2(x=0.1, input=a_traitV))
plot(x=a_traitV, y=scale2(x=0, input=a_traitV))
lines(x=a_traitV, y=scale2(x=0.9, input=a_traitV))
plot(x=a_traitV, y=scale2(x=0, input=a_traitV))
lines(x=a_traitV, y=scale2(x=0.7, input=a_traitV))
knitr::opts_chunk$set(echo = TRUE)
n_plants <- 3
n_animals <- 10
p_pops <- c(100, 500, 200)/10
p_traitM <- c(0.25, 0.99, 0.5)
p_traitV <- c(0.1, 0.1, 0.1) #All set to be the same in Becker paper
a_pops <- c(50, 100, 200, 100, 300, 670, 420, 78, 460, 92)/10
#a_pops <- c(0, 0, 0)
#a_pops <- c(.5, .1, .2)
a_traitM <- runif(10, 0, 1)
a_traitV <- runif(10, 0, .5)
#a_traitM <- c(0.2, 0.66, 0.8)
#a_traitV <- c(0.25, 0.5, 0.1)
factor_sites <- as.factor(1:nsites)
nsites <- 5
nsites <- 2
nsites <- 3
factor_sites <- as.factor(1:nsites)
#Setting up initial plant pops
p_pops <- matrix(data=round(runif(nsites*n_plants, 1, 200)), nrow=nsites, ncol=n_plants) #now, our pops are a matrix instead of a vector in order to track across multiple sites
p_traitM <- runif(n_plants, 0, 1)
p_traitV <- runif(n_plants, 0, .25)
#Setting up initial animal pops
a_pops <- matrix(data=round(runif(nsites*n_animals, 1, 200)), nrow=nsites, ncol=n_animals)
a_traitM <- runif(n_animals, 0.05, 1)
a_traitV <- runif(n_animals, 0.05, .25)
#Add our function for finding overlap
min.f1f2 <- function(x, mu1, mu2, sd1, sd2) {
f1 <- dnorm(x, mean=mu1, sd=sd1)
f2 <- dnorm(x, mean=mu2, sd=sd2)
pmin(f1, f2)
}
#pops <- NULL
p_pops_output <- cbind(c(1:nsites), rep(0,nsites),p_pops) #Make output dataframe; first column is site, second is timestep; then populations
a_pops_output <- cbind(c(1:nsites), rep(0,nsites),a_pops) #Make output dataframe; first column is site, second is timestep; then populations
prior_richness <- 0 #setting as the starting point
int_fail <- FALSE #Dummy variable for integral try statement
lambda_fail <- FALSE #Dummy variable for rpois() projection
P_TraitVTot <- NULL #Create a bunch of empty objects so we can rbind weighted mean trait variance to later
A_TraitVTot <- NULL
P_WTraitMean_output <- NULL
A_WTraitMean_output <-  NULL
propOutputtemp <- list() #Set up our realized specialism output object
pollBenefitsOutput <- list() #same for plants
#if so, recalculate niche overlap and competition matrices
#print("recalculating")
alpha <- matrix(nrow=n_animals, ncol=n_plants) #Create an empty matrix for plant-pollinator partnerships
alpha
n_sites <- 5
factor_sites <- as.factor(1:nsites)
#Setting up initial plant pops
p_pops <- matrix(data=round(runif(nsites*n_plants, 1, 200)), nrow=nsites, ncol=n_plants) #now, our pops are a matrix instead of a vector in order to track across multiple sites
p_traitM <- runif(n_plants, 0, 1)
p_traitV <- runif(n_plants, 0, .25)
#Setting up initial animal pops
a_pops <- matrix(data=round(runif(nsites*n_animals, 1, 200)), nrow=nsites, ncol=n_animals)
a_traitM <- runif(n_animals, 0.05, 1)
a_traitV <- runif(n_animals, 0.05, .25)
#Add our function for finding overlap
min.f1f2 <- function(x, mu1, mu2, sd1, sd2) {
f1 <- dnorm(x, mean=mu1, sd=sd1)
f2 <- dnorm(x, mean=mu2, sd=sd2)
pmin(f1, f2)
}
#pops <- NULL
p_pops_output <- cbind(c(1:nsites), rep(0,nsites),p_pops) #Make output dataframe; first column is site, second is timestep; then populations
a_pops_output <- cbind(c(1:nsites), rep(0,nsites),a_pops) #Make output dataframe; first column is site, second is timestep; then populations
prior_richness <- 0 #setting as the starting point
int_fail <- FALSE #Dummy variable for integral try statement
lambda_fail <- FALSE #Dummy variable for rpois() projection
P_TraitVTot <- NULL #Create a bunch of empty objects so we can rbind weighted mean trait variance to later
A_TraitVTot <- NULL
P_WTraitMean_output <- NULL
A_WTraitMean_output <-  NULL
propOutputtemp <- list() #Set up our realized specialism output object
propOutputtemp[[t]] <- list() #Make blank list entry for this timestep that we can fill in later with our plant benefit
pollBenefitsOutput[[t]] <- list() #Same thing above for the plants
#if so, recalculate niche overlap and competition matrices
#print("recalculating")
alpha <- matrix(nrow=n_animals, ncol=n_plants) #Create an empty matrix for plant-pollinator partnerships
alpha
for(ia in 1:n_animals){
if(int_fail==TRUE){ #If we've come across an integration failure, break the loop
break()
}
for(ip in 1:n_plants){
temp <- try(integrate(min.f1f2, -Inf, Inf, mu1=p_traitM[ip], mu2=a_traitM[ia], sd1=p_traitV[ip], sd2=a_traitV[ia])$value) #Integrate our minimum equation over all numbers; output is the total area overlapping both curves, with max value of perfectly overlapping curves as 1
if(class(temp)=='try-error'){
int_fail <- TRUE
break()
}
alpha[ia, ip] <- temp
#print(paste("ia=", ia, "; ip=", ip, sep=""))
}
}
alpha
alpha[alpha<0.05] <- 0
alpha
a_traitsV
a_traitV
a_traitVTot
A_TraitVTot
A_TraitV
scale_alpha <- function(x, input){
val <- (1-x)*((input-0.05)/0.2)+x
return(val)
}
scale_alpha(x=0.5, input=a_traitV)
scale_alpha(x=0.5, input=a_traitV)
scale_alpha(x=0.5, input=a_traitV)
scale_alpha(x=0.5, input=a_traitV)
u <- matrix(data=NA, nrow=n_plants, ncol=n_plants)
scale_alpha(x=0.5, input=a_traitV)
dim(alpha)
alpha%*%scale_alpha(x=0.5, input=a_traitV)
alpha%*%t(scale_alpha(x=0.5, input=a_traitV))
alpha
scale_alpha(x=0.5, input=a_traitV)
t(t(alpha) * scale_alpha(x=0.5, input=a_traitV))
scale_alpha(0, 0.25)
scale_alpha <- function(x, input){
val <- 1-(1-x)*((input-0.05)/0.2)+x
return(val)
}
scale_alpha(0, 0.25)
scale_alpha(0, 0.05)
scale_alpha(0.5, 0.05)
scale_alpha <- function(x, input){
val <- (1-x)*((0.25-input)/0.2)+x
return(val)
}
scale_alpha(0.5, 0.05)
scale_alpha(0.5, 0.25)
scale_alpha(0.4, 0.25)
scale_alpha(0.4, 0.05)
scale_alpha(x=genPen, input=p_traitV))
genPen <- 0.5
scale_alpha(x=genPen, input=p_traitV)
alpha
alpha*scale_alpha(x=genPen, input=p_traitV)
p_traitV
p_traitV
scale_alpha(x=genPen, input=p_traitV)
p_traitV
#Add function for penalizing generalist species.
scale_alpha <- function(x, input){
val <- (1-x)*((0.25-input)/0.2)+x
return(val)
}
alpha*scale_alpha(x=genPen, input=p_traitV)
scale_alpha(x=genPen, input=p_traitV)
p_traitV
scale_alpha
(1-0.002720814)*(0.25-0.002720814)/0.2
(1-0.002720814)*(0.25-0.002720814)/0.2 + 0.002720814
alpha*scale_alpha(x=genPen, input=p_traitV)
scale_alpha(x=genPen, input=p_traitV)
alpha
alpha*scale_alpha(x=genPen, input=p_traitV)
alpha*scale_alpha(x=genPen, input=p_traitV)
alpha*scale_alpha(x=genPen, input=p_traitV)
scale_alpha(x=genPen, input=p_traitV)
alpha%*%scale_alpha(x=genPen, input=p_traitV)
alpha%*%t(scale_alpha(x=genPen, input=p_traitV))
scale_alpha(x=genPen, input=p_traitV)%*%alpha
scale_alpha(x=genPen, input=p_traitV)%*%t(alpha)
scale_alpha(x=genPen, input=p_traitV)
test <- (0,0,1)
test <- c(0,0,1)
alpha*test
alpha*t(test)
dim(alpha)
alpha * test
test
# Create a sample 10 by 3 matrix
matrix_data <- matrix(1:30, nrow = 10, ncol = 3, byrow = TRUE)
# Create a sample vector of length 3
vector_data <- c(2, 3, 4)
vector_data <- c(0,0,1)
vector_data
matrix_data
matrix_data * vector_data
# Create a sample 10 by 3 matrix
matrix_data <- matrix(1:30, nrow = 10, ncol = 3, byrow = TRUE)
# Create a sample vector of length 3
vector_data <- c(2, 3, 4)
# Perform element-wise multiplication
result <- matrix_data * vector_data
# Output the result
print(result)
vector_data <- c(0,0, 4)
result <- matrix_data * vector_data
result
result <- sweep(matrix_data, 2, vector_data, "*")
result
?sweep
result <- sweep(matrix_data, 2, vector_data, "*")
matrix_data
matrix_data %*% vector_data
sweep(matrix_data, 2, vector_data, "*")
sweep(alpha, 2, scale_alpha(x=genPen, input=p_traitV), "*") #Apply our generalism penalty column-wise for plants
alpha
alpha <- sweep(alpha, 2, scale_alpha(x=genPen, input=p_traitV), "*") #Apply our generalism penalty column-wise for plants
alpha
alpha[alpha<0.05] <- 0
alpha
source(file="./GeneralismPenalty_TvsESpecialism_Sim.R") #load in our dispersal simulation function. rOxygen-style description available in file.
setwd("~/Documents/MetaCon/Analysis")
source(file="./GeneralismPenalty_TvsESpecialism_Sim.R") #load in our dispersal simulation function. rOxygen-style description available in file.
View(runDispersalSim)
