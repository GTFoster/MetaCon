---
title: "Discrete_Spatial_Landscape"
output: html_document
date: "2022-12-06"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(magrittr)
library(tidyverse)
library(scales)
```

Initial conditions

Familiar from previous versions, but now we're looking across a set of 10 connected patches. 
```{r}
nsites <- 5
factor_sites <- as.factor(1:nsites) #This is important for the dispersal function down the road
coords <- data.frame(x=runif(nsites), y=runif(nsites))
eucdist <- dist(coords, diag=T, upper=T)
dexpdist <- dexp(eucdist, rate=10)
dexpsim <- 1/(1+as.matrix(dexpdist)) #Converting our distance matrix to a similarity score (easier for me to then turn into a pmf).
#Found this particular metric from here: https://stats.stackexchange.com/questions/158279/how-i-can-convert-distance-euclidean-to-similarity-score
```

Visualizing sites

```{r}
plot(x=coords$x, y=coords$y, xlim=c(0,1), ylim=c(0,1))
for(i in 1:nsites){
  for(j in 1:nsites){
    if(i !=j ){
        segments(coords$x[i], coords$y[i], coords$x[j], coords$y[j], lwd=as.matrix(dexpdist)[i,j])
    }
  }
}
```

```{r}
n_plants <- 5
n_animals <- 5


p_pops <- matrix(data=round(runif(nsites*n_plants, 1, 200)), nrow=nsites, ncol=n_plants) #now, our pops are a matrix instead of a vector in order to track across multiple sites
p_traitM <- runif(n_plants, 0, 1)
p_traitV <- runif(n_plants, 0, .25)
#p_traitM <- c(0.25, 0.99, 0.5)
#p_traitV <- c(0.1, 0.1, 0.1) #All set to be the same in Becker paper


a_pops <- matrix(data=round(runif(nsites*n_animals, 1, 200)), nrow=nsites, ncol=n_animals)
a_traitM <- runif(n_animals, 0, 1)
a_traitV <- runif(n_animals, 0, .25)
```

Parameters
```{r}
r <- 0.5
mup <- .1
mua <- 0.25
o <- 0.1
lambda <- 0.9
K <- 100
e_thresh <- 2
invade_size <- 5
disprob <- 0.2


min.f1f2 <- function(x, mu1, mu2, sd1, sd2) {
    f1 <- dnorm(x, mean=mu1, sd=sd1)
    f2 <- dnorm(x, mean=mu2, sd=sd2)
    pmin(f1, f2)
}
```

#####Start Here: Figure out how to flexibly keep track of individual species as they enter the community/go extinct

```{r}
num_timeSteps <- 1000
p_rich <- NULL
a_rich <- NULL
WmeanV <- NULL
meanV <- NULL

#pops <- NULL
p_pops_output <- cbind(c(1:5), rep(0,nsites),p_pops) #Make output dataframe; first column is site, second is timestep; then populations
a_pops_output <- cbind(c(1:5), rep(0,nsites),a_pops) #Make output dataframe; first column is site, second is timestep; then populations

for(t in 1:num_timeSteps){
  #p_rich <- rbind(p_rich, n_plants)
  #a_rich <- rbind(a_rich, n_animals)
  #Check if community is same as in t-1
    #if so; recalculate A and u
  alpha <- matrix(nrow=n_animals, ncol=n_plants) #Create an empty matrix for plant-pollinator partnerships
  for(ia in 1:n_animals){
    for(ip in 1:n_plants){
    alpha[ia, ip] <- integrate(min.f1f2, -Inf, Inf, mu1=p_traitM[ip], mu2=a_traitM[ia], sd1=p_traitV[ip], sd2=a_traitV[ia])$value #Integrate our minimum equation over all numbers; output is the total area overlapping both curves, with max value of perfectly overlapping curves as 1
    #print(paste("ia=", ia, "; ip=", ip, sep=""))
    }
  }
  alpha[alpha<0.05] <- 0
  
  u <- matrix(data=NA, nrow=n_plants, ncol=n_plants)
  
  for(p1 in 1:n_plants){
    for(p2 in 1:n_plants){
      u[p1, p2] <- integrate(min.f1f2, -Inf, Inf, mu1=p_traitM[p1], mu2=p_traitM[p2], sd1=p_traitV[p1], sd2=p_traitV[p2])$value #Integrate our minimum equation over all numbers; output is the total area overlapping both curves, with max value of perfectly overlapping curves as 1
      }
  }
  #Find out dpop/dt
  a_change <- matrix(data=NA, nrow=nsites, ncol=n_animals)
    for(n in 1:n_animals){
    propOfplants <- 0
    nums <- alpha[n,]*p_pops#[,site]
    for(i in 1:n_plants){
      #Numerator-plant reward given by each focal pollinator
      propOfplants <- propOfplants+nums[,i]/(r+sum(alpha[,i]*a_pops)) #Denominator-scaled by total available pollen
    }
    pollDeath <- mua
    #print(propOfplants)
    a_change[,n] <- lambda*propOfplants - pollDeath
  } #Animal Growth Rate
  
  p_change <- matrix(data=NA, nrow=nsites, ncol=n_plants)
  for(n in 1:n_plants){
      plantCompetition <- (K-rowSums(t(u[n,]*t(p_pops))))/K#(K-sum(u[n,]*p_pops[n,]))/K
      #pollBenefits <-sum(alpha[,n]*a_pops*p_pops[n])/(r+sum(alpha[,n]*a_pops)) #NOTE: THIS IS MORE SIMILIAR TO BECKER. NOt sure why their p_pop is included here. 
      pollBenefits <-rowSums(t(alpha[,n]*t(a_pops)))/(r+rowSums(t(alpha[,n]*t(a_pops))))
      plantDeath <- mup
      p_change[,n] <- r*plantCompetition*pollBenefits - plantDeath# + o*rnorm(n=1, mean=0, sd=0.1) 
  }
  #Project to t+1
  for(i in 1:(n_plants*nsites)){
    #p_pops[i] <- sum(rpois(n=round(p_pops[i]),lambda = 1+p_change[i])) #Poisson birth process for plants
    p_pops[i] <- sum(rpois(n=round(p_pops[i]),lambda = exp(p_change[i])))
    #browser()
    #p_pops[i] <- temp
  }
  #p_pops <- p_pops*(1+p_change)
  #a_pops <- (a_change+1)*a_pops #Update Animal population
  for(i in 1:(n_animals*nsites)){
    #a_pops[i] <- sum(rpois(n=round(a_pops[i]),lambda = 1+a_change[i])) #Poisson birth process for animals
    a_pops[i] <- sum(rpois(n=round(a_pops[i]),lambda = exp(a_change[i])))
  }
  a_disprobs <- 1- (a_change/2 + 0.5) #Dispersal probability is proportional to local growth rate
  a_disprobs[a_disprobs<0] <- 0 #Species that more than double have their dispersal prob set to 0
  a_disprobs[a_disprobs>1] <- 1 #Species that really do poorly can't have a dispersal probability above 1
#Dispersal (occurs after demographics for year)
  #Decide number of animal dispersers from each site of each species
  a_emms <- matrix(rbinom(n=length(a_pops), size=a_pops, prob=a_disprobs), nrow=nsites)
  a_pops <- a_pops-a_emms #Remove our immigrants from our pops for now so we don't count them redundantly

  #animals disperse across sites
  for(site in 1:nsites){
    for(spp in 1:n_animals){
  destin <- sample(factor_sites, size=a_emms[site, spp], replace=TRUE, prob=dexpsim[site,]/sum(dexpsim[site,])) #Sample our sites a number of times equal to the emmigrants from a particular site.
  a_pops[,spp] <- a_pops[,spp] + as.matrix(table(destin), ncol=1) #Table summarizes how many immigrants go to each site and then we add them to the population size. 
    }
  }
  p_disprobs <- 1- (p_change/2 + 0.5) #Dispersal probability is proportional to local growth rate
  p_disprobs[p_disprobs<0] <- 0 #Species that more than double have their dispersal prob set to 0
  p_disprobs[p_disprobs>1] <- 1 #Species that really do poorly can't have a dispersal probability above 1
  #Now our plants can disperse
  p_emms <- matrix(rbinom(n=length(p_pops), size=p_pops, prob=disprob), nrow=nsites)
  p_pops <- p_pops-p_emms #Remove our immigrants from our pops for now so we don't count them redundantly

  #plants disperse across sites
  for(site in 1:nsites){
    for(spp in 1:n_plants){
      #browser()
  destin <- sample(factor_sites, size=p_emms[site, spp], replace=TRUE, prob=dexpsim[site,]/sum(dexpsim[site,])) #Sample our sites a number of times equal to the emmigrants from a particular site.
  p_pops[,spp] <- p_pops[,spp] + as.matrix(table(destin), ncol=1) #Table summarizes how many immigrants go to each site and then we add them to the population size. 
  #print(paste("site=", site, "; spp=", spp, sep=""))
    }
  }
  
  remove <- FALSE
  #Extinction?
  if(length(colSums(p_pops)[colSums(p_pops)<=e_thresh])>0){
    print("global plant extinction")
    remove <- TRUE
  }
  if(remove==TRUE){
    #Plant Extinction
    #p_traitM <- p_traitM[which(colSums(p_pops)>e_thresh)] #Remove trait values from globally exinct plants
    #p_traitV <- p_traitV[which(colSums(p_pops)>e_thresh)]
    #p_pops <- p_pops[,which(colSums(p_pops)>e_thresh)] #Stop tracking populations of globally extinct plants
    #Animal Extinction
    p_pops[,c(1:ncol(p_pops))[colSums(p_pops)<=e_thresh]] <- 0
    remove <- FALSE
  if(length(colSums(a_pops)[colSums(a_pops)<=e_thresh])>0){
    print("global animal extinction")
    remove <- TRUE
    a_pops[,c(1:ncol(a_pops))[colSums(a_pops)<=e_thresh]] <- 0 #enforce extinction, rounding down any below 2.
  } #HERE: Start with making this flexible
    #Problem: keeping species in as 0's makes calculations run slower due to matrix issues. However, it makes it much easier to keep track of our total population sizes. Not sure which direction to solve this in. 
    #a_traitM <- a_traitM[which(colSums(a_pops)>e_thresh)] #Remove trait values from globally extinct plants
    #a_traitV <- a_traitV[which(colSums(a_pops)>e_thresh)]
    #a_pops <- a_pops[,which(colSums(a_pops)>e_thresh)] #Stop tracking populations of globally extinct plants
  
  #Do we invade? 
    if(rbinom(1, 1, 0.25)==1){
    print("invasion")
     invasion <- runif(1)
     invasion_vector <- c(rep(0,nsites))
     invasion_vector[sample(1:nsites, size=1)] <- invade_size #choose a random site to invade with the invade_size; this is set up to be the same invader population size for plants and polls, but this could easily be split up
     if(invasion >=0.5){
       print("plant invades")
       p_pops <- cbind(p_pops, unlist(invasion_vector)) #new pop always invades a random site at invade_size; unlist is to get rid of that pesky name
       p_traitM <- c(p_traitM, runif(1)) #pick new trait mean from a uniform distribution [0,1]
       p_traitV <- c(p_traitV, 0.1) #All set to be the same in Becker paper
   }else{
     print("pollinator invades")
     a_pops <- cbind(a_pops, unlist(invasion_vector)) #new pop always invades a random site at invade_size
     a_traitM <- c(a_traitM, runif(1)) #pick new trait mean from a uniform distribution [0,1]
     a_traitV <- c(a_traitV, runif(1, 0, 0.5)) #Same for new trait variance
   }
   }
  n_animals <- ncol(a_pops)
  n_plants <- ncol(p_pops)
    
  if(n_animals < 1| n_plants < 1){
    print("Network breakdown")
      break
  }
  }
  #print(paste("polls=", n_animals, sep=""))
  #WmeanV <- rbind(WmeanV, sum((a_pops*a_traitV))/sum(a_pops))
  #meanV <- rbind(meanV, sum(a_traitV)/n_animals)
  #if(t %% 100==0)

if((ncol(a_pops)+2)>ncol(a_pops_output)){ #change the output dimensions to account for a new species
  print("Yup")
  a_pops_output <- cbind(a_pops_output, c(rep(0,nrow(a_pops_output))))#add a 0 for every preceeding timestep
  #colnames(a_pops_output)[ncol(a_pops_output)] <- colnames(a_pops)[ncol(a_pops)] # rename based on the newest animal species
}
a_pops_temp <- cbind(c(1:5), rep(t,nsites),a_pops)
a_pops_output <- rbind(a_pops_output, a_pops_temp)


if((ncol(p_pops)+2)>ncol(p_pops_output)){ #change the output dimensions to account for a new species
  p_pops_output <- cbind(p_pops_output, c(rep(0,nrow(p_pops_output))))
  #colnames(p_pops_output)[ncol(p_pops_output)] <- colnames(p_pops)[ncol(p_pops)] #  rename based on the newest plant species
}
p_pops_temp <- cbind(c(1:5), rep(t,nsites),p_pops)
p_pops_output <- rbind(p_pops_output, p_pops_temp)

  #pops <- rbind(pops, pops_temp)
  if(t %% 10==0)
  print(t)
}
```
```{r}
plant_long <- pivot_longer(as.data.frame(p_pops_output), cols=3:ncol(p_pops_output), names_to="species", values_to = "popsize")

ggplot(data=plant_long, aes(x=V2, y=popsize, color=as.factor(species)))+geom_line()+facet_wrap("V1")


an_long <- pivot_longer(as.data.frame(a_pops_output), cols=3:ncol(a_pops_output), names_to="species", values_to = "popsize")

ggplot(data=an_long, aes(x=V2, y=popsize, color=as.factor(species)))+geom_line()+facet_wrap("V1")

```
```{r}
plot(x=NA, y=NA, xlim=c(-1.5,1.5), ylim=c(0,10))
for(i in 1:length(a_traitM)){
  lines(x=seq(-2, 2, by=0.01), y=dnorm(x=seq(-2, 2, by=0.01), mean=a_traitM[i], sd=a_traitV[i]), col="dark red")
}
for(i in 1:length(p_traitM)){
  lines(x=seq(-2, 2, by=0.01), y=dnorm(x=seq(-2, 2, by=0.01), mean=p_traitM[i], sd=p_traitV[i]), col="dark green")
}


plot(x=NA, y=NA, xlim=c(-1.5,1.5), ylim=c(0,10))
for(i in (1:length(a_traitM))[colSums(a_pops)>0]){
  lines(x=seq(-2, 2, by=0.01), y=dnorm(x=seq(-2, 2, by=0.01), mean=a_traitM[i], sd=a_traitV[i]), col="dark red")
}
for(i in (1:length(p_traitM))[colSums(p_pops)>0]){
  lines(x=seq(-2, 2, by=0.01), y=dnorm(x=seq(-2, 2, by=0.01), mean=p_traitM[i], sd=p_traitV[i]), col="dark green")
}

(1:length(a_traitM))[colSums(a_pops)>0]
```


```{r}
poplong <- pivot_longer(pops, cols = 1:(n_plants+n_animals), names_to="species", values_to = "popsize")
#ggplot(data=poplong, aes(x=time, y=popsize, color=species))+geom_line()+ scale_color_manual(values=c("#660000", "#990000", "#006600", "#006633"))+facet_wrap("site")


ggplot(data=poplong, aes(x=time, y=popsize, color=species))+geom_line()+ scale_color_manual(values=c("#660000", "#990000", "#CC0000", "#FF0000", "#FF3333", "#006600", "#006633", "#193300", "green", "dark green"))+facet_wrap("site")
```

